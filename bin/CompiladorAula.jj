/**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */

options
{
  static = false;
}

PARSER_BEGIN(CompiladorAula)

public class CompiladorAula {

  
    // Flag para saber se houve erro sint√°tico durante a an√°lise
    private boolean houveErroSintatico = false;

    public boolean houveErroSintatico() {
        return houveErroSintatico;
    }

    public void limparErrosSintaticos() {
        houveErroSintatico = false;
    }

    /* Registra um erro sint√°tico (por enquanto s√≥ marca a flag e imprime algo simples) */
    void registrarErroSintatico(ParseException e, String contexto) {
        houveErroSintatico = true;

        Token errorToken = (e.currentToken != null) ? e.currentToken.next : null;
        String foundToken = (errorToken != null) ? errorToken.image : "EOF";
        int line   = (errorToken != null) ? errorToken.beginLine   : 0;
        int column = (errorToken != null) ? errorToken.beginColumn : 0;

        System.out.println("\nüíÄ ERRO SINT√ÅTICO (modo p√¢nico) no mundo Minecraft!");
        System.out.println(" Contexto: " + contexto);
        System.out.println(" Localiza√ß√£o: Linha " + line + ", Coluna " + column);
        System.out.println(" Token encontrado: '" + foundToken + "'");
    }

    /*
     * Modo p√¢nico: descarta tokens at√© encontrar um ponto de sincroniza√ß√£o
     * (fim de comando ou in√≠cio de um novo comando/bloco).
     */
    void sincronizarComando() {
        Token t;
        while (true) {
            t = getNextToken(); // avan√ßa um token

            if (t.kind == EOF) {               // fim do arquivo
                break;
            }

            // Fim de comando
            if (t.kind == PONTOVIRGULA) {
                break;
            }

            // In√≠cio de novos comandos/declara√ß√µes/blocos
            if (t.kind == IF          // vinicius13
             || t.kind == WHILE       // em_busca_da_casa_automatica
             || t.kind == FOR         // intro_do_venom_extreme
             || t.kind == PRINTF      // chat
             || t.kind == TIPOINTEIRO // pedra
             || t.kind == TIPOFLUTUANTE // agua
             || t.kind == TIPOTEXTO   // placa
             || t.kind == TIPOBINARIO // redstone
             || t.kind == BEDROCK     // fim do mundo
             || t.kind == FECHARIF    // gamemode_survival
             || t.kind == FECHARWHILE // farm_de_cana_de_acucar
             || t.kind == FECHARFOR   // portal_do_nether
            ) {
                // chegou num ponto "seguro": para de descartar
                break;
            }
        }
        // ap√≥s isso, o parser segue a partir do ponto onde parou
	}

  public static void main(String[] args) throws ParseException {
        CompiladorAula parser = new CompiladorAula(System.in);

        while (true) {
            System.out.println("WELCOME TO THE WORLD MUITO FODDAAAAAAAA");
            System.out.print("Start new world ----- > ");

            try {
                parser.limparErrosSintaticos();   // zera flag antes da an√°lise

    			parser.main();                    // roda o parser

    			if (parser.houveErroSintatico()) {
      			  System.out.println("\n‚ùå Mundo N√ÉO aceito pela linguagem Minecraft.");
        			System.out.println("Veja as mensagens de erro acima (modo p√¢nico).");
    			}
    			else {
        			System.out.println("‚úÖ Entering the world... Mundo aceito com sucesso!");
   				 }
            } catch (ParseException e) {
                // Extrair informa√ß√µes de token do ParseException
                Token errorToken = e.currentToken != null ? e.currentToken.next : null;
                String foundToken = errorToken != null ? errorToken.image : "EOF";
                int line = errorToken != null ? errorToken.beginLine : 0;
                int column = errorToken != null ? errorToken.beginColumn : 0;
                
                // Extrair tokens esperados do ParseException
                StringBuilder expectedTokens = new StringBuilder();
                if (e.expectedTokenSequences != null && e.tokenImage != null) {
                    for (int i = 0; i < e.expectedTokenSequences.length && i < 3; i++) {
                        if (i > 0) expectedTokens.append(", ");
                        if (e.expectedTokenSequences[i].length > 0) {
                            int tokenId = e.expectedTokenSequences[i][0];
                            if (tokenId < e.tokenImage.length) {
                                expectedTokens.append(e.tokenImage[tokenId].replace("\"", ""));
                            }
                        }
                    }
                }
               
                String errorMsg = e.getMessage().toLowerCase();
                
                // Cabe√ßalho comum com informa√ß√µes de token
                System.out.println("\nüíÄ ERRO SINT√ÅTICO no mundo Minecraft!");
                System.out.println(" Localiza√ß√£o: Linha " + line + ", Coluna " + column);
                System.out.println(" Token encontrado: '" + foundToken + "'");
                if (expectedTokens.length() > 0) {
                    System.out.println(" Token(s) esperado(s): " + expectedTokens.toString());
                }
                
                // Mensagens espec√≠ficas por tipo de erro
                if (errorMsg.contains("createworld")) {
                    System.out.println(" CONTEXTO: Voc√™ esqueceu de criar o mundo!");
                    System.out.println(" SOLU√á√ÉO: Use 'createworld <nome>' para come√ßar sua aventura");
                } else if (errorMsg.contains("overworld")) {
                    System.out.println(" CONTEXTO: Portal para o Overworld n√£o encontrado!");
                    System.out.println(" SOLU√á√ÉO: Use 'overworld' para entrar na dimens√£o principal");
                } else if (errorMsg.contains("bedrock")) {
                    System.out.println(" CONTEXTO: Bedrock n√£o encontrado - mundo inst√°vel!");
                    System.out.println(" SOLU√á√ÉO: Termine seu c√≥digo com 'bedrock' para estabilizar o mundo");
                } else if (errorMsg.contains("pontovirgula") || errorMsg.contains(";")) {
                    System.out.println(" CONTEXTO: Comando incompleto - faltou terminar a linha!");
                    System.out.println(" SOLU√á√ÉO: Adicione ';' no final do comando");
                } else if (errorMsg.contains("gamemode_creative") || errorMsg.contains("gamemode_survival")) {
                    System.out.println(" CONTEXTO: Modo de jogo inv√°lido!");
                    System.out.println(" SOLU√á√ÉO: Use 'gamemode_creative' para abrir blocos condicionais");
                } else if (errorMsg.contains("vinicius13")) {
                    System.out.println(" CONTEXTO: Condi√ß√£o if mal formada!");
                    System.out.println(" SOLU√á√ÉO: Use 'vinicius13 <condi√ß√£o> gamemode_creative build'");
                } else if (errorMsg.contains("parentes")) {
                    System.out.println(" CONTEXTO: Par√™nteses mal formados!");
                    System.out.println(" SOLU√á√ÉO: Verifique se todos os '(' t√™m seus ')' correspondentes");
                } else if (errorMsg.contains("string")) {
                    System.out.println(" CONTEXTO: String mal formada!");
                    System.out.println(" SOLU√á√ÉO: Use aspas simples: 'sua mensagem aqui'");
                } else {
                    System.out.println(" CONTEXTO: Sintaxe n√£o reconhecida no mundo Minecraft!");
                    System.out.println(" SOLU√á√ÉO: Consulte a documenta√ß√£o da linguagem");
                }
                
				parser.ReInit(System.in);
            } catch (TokenMgrError e) {
                // Extrair informa√ß√µes de linha e coluna do TokenMgrError
                String errorMsg = e.getMessage();
                int line = 0, column = 0;
                char foundChar = '?';
                
                // Extrair linha e coluna da mensagem do TokenMgrError
                if (errorMsg.contains("line ") && errorMsg.contains("column ")) {
                    try {
                        String[] parts = errorMsg.split("line ")[1].split(",");
                        line = Integer.parseInt(parts[0].trim());
                        column = Integer.parseInt(parts[1].split("column ")[1].split("\\.")[0].trim());
                    } catch (Exception ex) {
                        // Se falhar, usar valores padr√£o
                    }
                }
                
                // Extrair caractere encontrado
                if (errorMsg.contains("Encountered: '") && !errorMsg.contains("<EOF>")) {
                    try {
                        String charPart = errorMsg.split("Encountered: '")[1];
                        if (charPart.length() > 0) {
                            foundChar = charPart.charAt(0);
                        }
                    } catch (Exception ex) {
                        // Se falhar, usar valor padr√£o
                    }
                }
                
                // Cabe√ßalho comum com informa√ß√µes de token
                System.out.println("\nüíÄ ERRO L√âXICO no mundo Minecraft!");
                System.out.println(" Localiza√ß√£o: Linha " + line + ", Coluna " + column);
                System.out.println(" Caractere encontrado: '" + foundChar + "'");
                System.out.println(" Esperado: caracteres v√°lidos da linguagem Minecraft");
                
                if (errorMsg.contains("Lexical error")) {
                    System.out.println(" CONTEXTO: Caractere n√£o reconhecido no mundo Minecraft!");
                    System.out.println(" SOLU√á√ÉO: Use apenas letras, n√∫meros, '_', operadores v√°lidos");
                    System.out.println(" OPERADORES: combine, -, *, /, <-, stronger, weaker, =, <>, etc.");
                } else if (e.errorCode == TokenMgrError.LEXICAL_ERROR) {
                    System.out.println(" CONTEXTO: Erro de an√°lise lexical!");
                    System.out.println(" SOLU√á√ÉO: Verifique caracteres especiais ou encoding do arquivo");
                } else {
                    System.out.println(" CONTEXTO: Erro do analisador de tokens");
                    System.out.println(" DETALHES: " + errorMsg);
                }
                
                parser.ReInit(System.in);
            } catch (Exception e) {
                // Erros gerais com tema Minecraft
                System.out.println("\nüíÄ VOC√ä MORREU!");
                System.out.println(" Causa da morte: " + e.getClass().getSimpleName());
                
                if (e instanceof NullPointerException) {
                    System.out.println(" Voc√™ tentou usar uma vari√°vel que n√£o existe (como tentar usar um item vazio)");
                } else if (e instanceof NumberFormatException) {
                    System.out.println(" N√∫mero inv√°lido detectado - verifique seus valores num√©ricos");
                } else if (e instanceof ArrayIndexOutOfBoundsException) {
                    System.out.println(" Voc√™ tentou acessar um slot do invent√°rio que n√£o existe");
                } else {
                    System.out.println(" Erro inesperado durante a execu√ß√£o: " + e.getMessage());
                }
                
                System.out.println(" Respawnando...");
                parser.ReInit(System.in);
            } catch (Error e) {
                // Erros fatais
                System.out.println("\nüíÄ VOC√ä CAIU NO VOID!");
                System.out.println(" Erro fatal do sistema - mundo corrompido!");
                
                if (e instanceof StackOverflowError) {
                    System.out.println(" Stack overflow - recurs√£o infinita detectada (como um loop de redstone infinito)");
                } else if (e instanceof OutOfMemoryError) {
                    System.out.println(" Mem√≥ria esgotada - muito processamento (como muitos TNTs explodindo)");
                } else {
                    System.out.println(" Erro cr√≠tico: " + e.getMessage());
                }
                
                System.out.println("üî¥ Saindo do jogo...");
                break;
            }
        }
    }
}

PARSER_END(CompiladorAula)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /*PALAVRAS RESERVADAS */
{
  < CREATEWORLD    : "createworld"                        >
| < OVERWORLD      : "overworld"                          >
| < BEDROCK        : "bedrock"                            >
| < TIPOINTEIRO    : "pedra"                              >
| < TIPOFLUTUANTE  : "agua"                               >
| < TIPOTEXTO      : "placa"                              >
| < TIPOBINARIO    : "redstone"                           >
| < IF             : "vinicius13"                         >
| < THEN           : "build"                              >
| < ELSE           : "monark"                             >
| < TRUE           : "tocha_acessa"                       >
| < FALSE          : "tocha_apagada"                      >
| < PRINTF         : "chat"                               >
| < CONTINUE       : "isolaaados"                         >
| < AND            : "repetidor"                          >
| < OR             : "or"                                 >
| < NOT            : "tocha_invertida"                    >
| < ABRIRELSE      : "acordaaaa_gente"                    >
| < FECHARELSE     : "ja_tamo_na_ditadura"                >
| < ABRIRIF        : "gamemode_creative"                  >
| < FECHARIF       : "gamemode_survival"                  >
| < WHILE          : "em_busca_da_casa_automatica"        >
| < ABRIRWHILE     : "farm_de_ferro"                      >
| < FECHARWHILE    : "farm_de_cana_de_acucar"             >
| < BREAK          : "kill"                               >
| < FOR            : "intro_do_venom_extreme"             >
| < ABRIRFOR       : "portal_do_aether"                   >
| < FECHARFOR      : "portal_do_nether"                   >
} 

TOKEN : /*OPERADORES*/
{
	< SOMA: "combine"          >
|	< SUBTRACAO: "-"           >
|	< MULTIPLICACAO: "*"       >
|	< DIVISAO: "/"             >	
|	< ATRIBUICAO: "<-"         >
|	< MAIOR: "stronger"        >
|	< MENOR: "weaker"          >
|	< MENOR_IGUAL: "<="        >
|	< MAIOR_IGUAL: ">="        >
|	< DIFERENTE: "<>"          > 
|	< IGUAL: "="               >
}

TOKEN :
{
  < DECIMAL            : (< DIGITO >)+ ( "." (<DIGITO>)+ )?                                  >
| < DIGITO             : [ "0"-"9" ]                                                         >
| < ID                 : ["a" - "z" , "A" - "Z"](["a" - "z" , "A" - "Z" , "0" - "9", "_"])*  > 
| < LETRA              : ["A" - "Z" ] | ["a" - "z"]                                          >
| < PONTOVIRGULA       : ";"                                                                 >
| < VIRGULA            : ","                                                                 >
| < STRING             : "'" (~["'"])* "'"                                                   >
| < PARENTES_ESQUERDA  : "("                                                                 >
| < PARENTES_DIREITA   : ")"                                                                 >
| < DELIMITAR_VARCHAR  : "'"                                                                 > 
}

/* ---------------------------------------------------- START BLOCO PRINCIPAL ---------------------------------------------------------------------------------*/
void main() : {}
{
  <CREATEWORLD> <ID> <PONTOVIRGULA> 
  bloco()
}

void bloco() : { }
{
  <OVERWORLD>
  (sentencaRecuperavel())* 
  <BEDROCK>
}

/* ---------------------------------------------------- END BLOCO PRINCIPAL ---------------------------------------------------------------------------------*/

void comando() : {} 
{
  atribuicao()
 | ifStmt()
 | whileLoop()
 | forLoop() 
 | breakStmt()
 | printStmt()
 | continueStmt()
}

/* Uma senten√ßa dentro de um bloco: declara√ß√£o ou comando */
void sentenca() : {}
{
    declaracaoVariavel()
  | comando()
}

/** Senten√ßa com recupera√ß√£o em modo p√¢nico */
void sentencaRecuperavel() : {}
{
  try
  {
    sentenca()
  }
  catch (ParseException e)
  {
    {
      registrarErroSintatico(e, "Erro em uma senten√ßa dentro do bloco (overworld/if/while/for).");
      sincronizarComando();
    }
  }
}
/* ---------------------------------------------------- START BLOCO WHILE ---------------------------------------------------------------------------------*/
void whileLoop() : {}
{
  <WHILE> expressao()
  <ABRIRWHILE> blocoWhile() <FECHARWHILE>
}

void blocoWhile() : {} { ( sentencaRecuperavel())+ }

void breakStmt() : {}
{
  <BREAK> <PONTOVIRGULA>
}

/* ---------------------------------------------------- END BLOCO WHILE ---------------------------------------------------------------------------------*/

void continueStmt() : {} { <CONTINUE> <PONTOVIRGULA> }

/* ---------------------------------------------------- START BLOCO FOR ---------------------------------------------------------------------------------*/
void forLoop() : {}
{
  <FOR> <PARENTES_ESQUERDA>
  forInitOpt() <PONTOVIRGULA>
  forCondOpt() <PONTOVIRGULA>
  forUpdateOpt()
  <PARENTES_DIREITA>
  <ABRIRFOR> blocoFor() <FECHARFOR>
}

void blocoFor() : {} { ( sentencaRecuperavel())+ }

void forInitOpt()   : {} { ( forInit() )? }
void forCondOpt()   : {} { ( expressao() )? }
void forUpdateOpt() : {} { ( atribuicaoFor() ( <VIRGULA> atribuicaoFor() )* )? }

void forInit() : {}
{
    tipoDado() listaDeclaracoes()
  | atribuicaoFor()
}

void atribuicaoFor() : {}
{
  <ID> <ATRIBUICAO> expressao()
}

/* ---------------------------------------------------- END BLOCO FOR ---------------------------------------------------------------------------------*/

/* ---------------------------------------------------- START ESTRUTURA DE CONTROLE ---------------------------------------------------------------------------------*/
void ifStmt() : {}
{
  <IF> expressao()
  <ABRIRIF> <THEN>
  blocoIf()
  <FECHARIF>
  ( elseClause() )?
}

void elseClause() : {}
{
  <ELSE> <ABRIRELSE>
  blocoElse()
  <FECHARELSE>
}

void blocoIf()   : {} { (sentencaRecuperavel())+ }
void blocoElse() : {} { (sentencaRecuperavel())+ }

/* ---------------------------------------------------- END ESTRUTURA DE CONTROLE ---------------------------------------------------------------------------------*/

/* ---------------------------------------------------- START ATRIBUI√á√ÉO ---------------------------------------------------------------------------------*/
void atribuicao() : {}
{
  <ID> <ATRIBUICAO> expressao() <PONTOVIRGULA>
}
/* ---------------------------------------------------- END ATRIBUI√á√ÉO ---------------------------------------------------------------------------------*/

/* ---------------------------------------------------- START PRINTF ---------------------------------------------------------------------------------*/
void printStmt() : {}
{
  <PRINTF> <PARENTES_ESQUERDA> <STRING> <PARENTES_DIREITA> <PONTOVIRGULA>
}

/* ---------------------------------------------------- END PRINTF ---------------------------------------------------------------------------------*/

/* ---------------------------------------------------- START CONTROLE DE EXPRESS√ïES ---------------------------------------------------------------------------------*/

/* ---------------------------------------------------- START EXPRESSOES (LL(1)) ------------------------------*/

// Express√£o completa (n√≠vel mais alto: OR)
void expressao() : {}
{
  exprOr()
}

// exprOr -> exprAnd (OR exprAnd)*
void exprOr() : {}
{
  exprAnd() exprOrLinha()
}

void exprOrLinha() : {}
{
  ( <OR> exprAnd() exprOrLinha() )?
}

// exprAnd -> exprRel (AND exprRel)*
void exprAnd() : {}
{
  exprRel() exprAndLinha()
}

void exprAndLinha() : {}
{
  ( <AND> exprRel() exprAndLinha() )?
}

// exprRel -> exprAditiva (RelOp exprAditiva)?
void exprRel() : {}
{
  exprAditiva() exprRelLinha()
}

void exprRelLinha() : {}
{
  ( tipoCondicao() exprAditiva() )?
}

// exprAditiva -> exprMultiplicativa ( (+|-) exprMultiplicativa )*
void exprAditiva() : {}
{
  exprMultiplicativa() exprAditivaLinha()
}

void exprAditivaLinha() : {}
{
  ( ( <SOMA> | <SUBTRACAO> ) exprMultiplicativa() exprAditivaLinha() )?
}

// exprMultiplicativa -> exprUnaria ( (*|/) exprUnaria )*
void exprMultiplicativa() : {}
{
  exprUnaria() exprMultiplicativaLinha()
}

void exprMultiplicativaLinha() : {}
{
  ( ( <MULTIPLICACAO> | <DIVISAO> ) exprUnaria() exprMultiplicativaLinha() )?
}

// exprUnaria -> NOT exprUnaria | prim√°ria
void exprUnaria() : {}
{
    <NOT> exprUnaria()
  | exprPrimaria()
}

// prim√°ria -> ID | DECIMAL | STRING | TRUE | FALSE | mudanca completa tenho que testar todos os casos 
void exprPrimaria() : {}
{
    <ID>
  | <DECIMAL>
  | <STRING>
  | <TRUE>
  | <FALSE>
  | <PARENTES_ESQUERDA> expressao() <PARENTES_DIREITA>
}

/* ---------------------------------------------------- END EXPRESSOES (LL(1)) --------------------------------*/

/* ---------------------------------------------------- END CONTROLE DE EXPRESS√ïES ---------------------------------------------------------------------------------*/

/* ---------------------------------------------------- START DECLARACAO VARIAVEL ---------------------------------------------------------------------------------*/

void declaracaoVariavel() : {}
{
  tipoDado() listaDeclaracoes() <PONTOVIRGULA>
}

void listaDeclaracoes() : {}
{
  declaracaoUnica() ( <VIRGULA> declaracaoUnica() )*
}

void declaracaoUnica() : {}
{
  <ID> ( <ATRIBUICAO>  expressao() )?
}

/* ---------------------------------------------------- END DECLARACAO VARIAVEL ---------------------------------------------------------------------------------*/

/* ---------------------------------------------------- START TIPOS DE DADOS---------------------------------------------------------------------------------*/

void tipoDado() : {} 
{
  < TIPOINTEIRO > | <  TIPOBINARIO > | < TIPOTEXTO > | < TIPOFLUTUANTE >
}
/* ---------------------------------------------------- END TIPOS DE DADOS ---------------------------------------------------------------------------------*/

/* ---------------------------------------------------- STAR TIPO DE CONDI√á√ÉO ---------------------------------------------------------------------------------*/

void tipoCondicao() : {} 
{
  <MAIOR> | <MENOR> | <MAIOR_IGUAL> | <MENOR_IGUAL> | <IGUAL> | <DIFERENTE> 
}

/* ---------------------------------------------------- STAR TIPO DE CONDI√á√ÉO ---------------------------------------------------------------------------------*/